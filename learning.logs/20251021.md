Backend -> cardatabase2를 기준으로 합니다.
Frontend -> carfront를 기준으로 합니다.

둘다 켜면 현재 getCars() 함수를 불러와서 초기 페이지에
자동차 세 대 데이터가 나옵니다.
CommandLineRunner에 집어넣은 더미 데이터를 불러옴.

# 환경 변수 이용
서버 URL은 CRUD 기능을 만들 때 소스 코드에서 여러 번 반복될 수 있으며, 백엔드가 배포가 되면 localhost:8080이 아니기 때문에 환경 변수로 미리 정의해두는 것이 좋습니다. 예를 들어서 수정이 이루어지고 나면 갱신된 getCars()가 다시 요청되어야 할겁니다. 그러면 수정 부분에 있는 localhost:8080과 다시 getCars()를 요청할 때의 localhost:8080을 매번 URL로 전부 다 고치는 것은 비효율적입니다(그리고 이건 하드코딩에 해당).

그래서 환경변수에 URL을 저장해두게 되면, URL이 바뀔때 환경 변수만 수정해주면 일괄 변환이 될 것이기 때문에 환경 변수 설정을 미리 하고 다음 과정으로 넘어가겠습니다.

vite project 상에서는 환경변수 이름은 `VITE_` 로 시작해야 합니다. 접두사가 VITE_인 변수만 소스 코드에서 접근이 가능.

1. 앱의 루트 폴더에 `.env` 파일생성

`VITE_API_URL=http://localhost:8080`

2. src 폴더 내에 api 폴더 생성 -> carapi.ts 파일 생성
  - 이상은 모든 API 호출 함수를 자체 모듈로 분리하는 과정입니다. 즉 현재 상황에서는 getCars()를 Carlist 컴포넌트에서 분리해오겠다는 의미.

- .env 파일이 src 내부에 있는 경우가 많았음. 가장 상위에 둘것.

# 페이징 / 필터링 / 정렬 추가
- github 때는 Ag Grid 썻는데, 이번에는 MUI 기준으로 작성해보도록 할 예정입니다.
- 터미널에서 npm install @mui/x-data-grid@8.4.0

# 삭제 기능 추가

- 이제 중요한 점은 삭제를 하기 위해서는 특정 row를 선택해야 한다는 점과, 엔드포인트에 {id}가 추가되어야 한다는 점.

- 근데 우리는 각 row에 대한 href를 가지고 있따는 점에 주목할 필요가 있음.

```json
{
                "brand": "Kia",
                "model": "Seltos",
                "color": "Chacol",
                "registrationNumber": "370SU5690",
                "modelYear": 2020,
                "price": 30000000,
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "car": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "owner": {
                        "href": "http://localhost:8080/api/cars/1/owner"
                    }
```
HATEOAS를 적용했기 때문에 각각의 id값이 자동으로 설정되어있습니다. 즉 DELETE method를 _links.self.href로 보내주면 알아서 삭제가 될거라고 생각할 수 있겠습니다.

그래서 현재 GET 요청을 통해서 `import.meta.env.VITE_API_URL/api/cars`를 하게 됐을 때 x-data-grid에 의해서 각 자동차 row들이 나오고 있습니다. x-data-grid의 GridColDef를 수정하여 버튼을 하나 추가하고, 거기에 삭제 기능을 적용할것.

왜냐면 key 속성에 이미 _link.self.href 값이 있기 때문.

GridColDef에 딸린 coloumns 상수를 수정하여 하나의 column을 추가했습니다. 여기에는 Delete 버튼을 할당했습니다. 다른 컬럼들과 달리 세세한 커스텀이 필요하기 때문에 renderCell 컬럼 속성을 사용하여 셀의 컨텐츠가 렌더링되는 방식을 정의했습니다(여기서는 button 태그를 집어넣었습니다). 그리고 현재 상황에서는 alert을 통해 _links.self.href를 불러오는지를 확인했는데, 여기서 중요한 개념이
onClick={() => alert(_links.self.href)}를 쓰게 되면 애초에 함수의 결과값이 출력될거기 때문에 버튼을 누르는 것과는 상관이 없다는 결과가 나올겁니다.
onClick={() => alert(_links.self.href)} 과의 차이점을 명확하게 알 필요가 있습니다.

함수의 이름을 이벤트 핸들러에 전달 / 함수의 결과를 이벤트 핸들러에 전달하는 것의 차이점을 복습할 필요가 있습니다. -> 그리고 매개변수가 존재하는 함수의 이름만 전달하는 방법이 무엇일까를 고려하셔야 합니다.

button 태그 내에 sort / filter를 비활성화 시켰고, 컬럼의 메뉴를 비활성화 시키는 disableColumnMenu를 true로 설정했습니다.
그리고 onClick 이벤트도 설정했습니다.

다음 과정을 좀 고민해봐야 합니다. 각 row들마다 href가 존재하기 때문에 delete 요청을 날릴 수 있을 것 같습니다.

현재까지의 코드를 확인해본 결과, 일단 cardatabase_2를 기준으로 지금 back-front 연결을 하고 있는 것은 맞는데, 얘가 Spring Data REST를 기반으로 하고 있다보니까 로직 설명이 되고있지 않다는 것을 알 수 있습니다.

즉, 코드 자체를 보고 로직을 떠올리기 위해서는 cardatabase_4의 CarController와 CarService를 확인할 필요가 있습니다.

Axios의 delete 메서드를 이용하여 DELETE 요청을 보낼건데, DELETE 요청의 경우에는 id값이 필요하다는것을 CarService에서 확인할 수 있었습니다. 그런데 id 값은 어디에 있다? href에 있다.

그리고 우리는 함수들을 frontend에서 다 분리를 했습니다. 그렇다면 deleteCar 함수를 작성해야하는 파일은 어디? getCars를 정의한곳에서.

```ts
// carapi.ts
import axios from "axios";
import { CarResponse } from "../types";

export const getCars = async(): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);

    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link);
    return response.data
} 
```
getCars()의 return 타입과 deleteCar()의 return 타입의 차이를 생각할 필요가 있습니다. getCars()의 경우 자동차들의 정보를 담고있는 배열만 가지고 와서 그것을 Carlist 컴포넌트의 return에 표기하면 되는 반면에, 삭제후에는 GET 요청이후의 완전한 JSON이 return될 필요가 있습니다. 그 차이로 인해서 ._embedded 유무가 결정나는 것.

현재 deleteCar() 메서드를 호출하기 위해 useMutation() hook을 적용했습니다. 그리고 삭제 버튼을 눌렀을 때, 삭제가 DB에서는 됐지만 frontend 상에서는 새로고침을 해야지만 이루어진다는 점도 확인되죠.

그렇다면 onSuccess는 삭제 이후에, 새로 프론트엔드에 갱신되 cars 정보를 가지고 오는 것이 될겁니다.

즉, 이제 구현할 부분은 자동차가 삭제되면 프론트엔드를 자동으로 새로고침할 수 있도록 하는 것입니다. react query에서 가져온 데이터는 쿼리 클라이언트가 처리하는 캐시에 저장됩니다. 쿼리 클라이언트에는 데이터를 _다시 가져오는 데 이용할 수 있는 쿼리 무효화_ 기능이 있습니다.

물론 useEffaect()에서 콜백함수를 통해 getCars()를 호출하는데, `[cars]`를 통해서 cars의 상태가 변화될 때마다 제랜더링을 일으키는 방법도 있을 겁니다. 그런데 현재 저희가 작성한 방식을 봤을 때 , useState를 사용하지 않았고, useQuery를 통해서 getCars()를 불러오고 있는 상황이기 때문에 cache에 cars 데이터가 저장돼있을거란 점을 이용해서 코드를 작성할겁니다.

쿼리 무효화 기능을 적용하기 위해 먼저 현재의 쿼리 클라이언트를 반환하는 useQueryClient 훅 함수를 가져왔습니다.
```tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars , deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams} from "@mui/x-data-grid";

function Carlist(){         // 이 부분 입니다.
  const queryClient = useQueryClient();
  const {data,error,isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });
```

## useMutation

```jsx
import { useMutation } from "@tanstack/react-query";
// useMutation이 return 하는 객체에는 이 세가지 말고도 여러 속성값이 있습니다.
const { data, isLoading, mutate } = useMutation(mutationFn, options);
```

useQuery가 GET 요청으로 데이터를 불러 오는데 사용된다면 useMutation은 **React Query를 이용해 서버에 데이터 변경 작업을 요청할 때 사용**합니다.  `isLoading` 과 `data`는 useQuery와 같이 완료 여부와, 데이터를 반환하지만 `mutate`은 mutationFn으로 제공된 함수를 작동시키는 트리거 함수입니다.

**useMutation에 들어가는 인자 값**

1. `mutationFn`:  데이터를 수정하고 업데이트하고 삭제하는데 사용할 함수입니다. fetch나 axios를 사용하여 promise를 반환하는 함수가 와야합니다.
2. `options`:  useMutation에도 많은 옵션이 있지만 많이 쓰는 4가지 옵션이 있습니다.
    - `onMutate`: Promise 객체를 반환하는 Callback 함수로써 mutation 함수가 실행되기 전에 실행되고 mutation 함수와 동일한 변수가 제공됩니다.
    - `onError`: mutation이 실패한 경우 실행할 Callback 함수 입니다.
    - `onSettled`:  mutation이 실패 또는 성공 여부에 관계 없이 실행할 Callback 함수 입니다.
    - `onSuccess`: mutation이 성공한 경우 실행할 Callback 함수 입니다.

아래는 실제 사용 예시입니다.
// getPosts  함수는 게시물 목록을 가져오는 함수입니다.
```tsx
export const getPosts = async () => {
  const { data }= await axios.get("http://localhost:8080/post");
  return data;
};

// createPost 함수는 게시물을 생성하는 함수입니다.
export const createPost = async (title, content) => {
	await axios.post("http://localhost:8080/post", {
      title,
      content,
    });
};

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { getPosts, createPost } from "./api.js"

export default function App() {
	const queryClient = useQueryClient();
	const { isLoading, data: posts } = useQuery("posts", getPosts);
	const createMutate = useMutation(
	    ({ title, content }) => {
	      createPost(title, content);
	    },
	    {
	      onSuccess: () => {
					// 비동기 통신이 성공적으로 이루어 졌을때
					// posts 라는 queryKey를 찾아 데이터를 새로 받아옵니다.
	        queryClient.invalidateQueries("posts"); 
	      },
	    }
	  );

	const handleSubmit = async (e) => {
    e.preventDefault();
    const { title, content } = e.target;
		
		// 위에서 선언한 createMutate의 mutate함수를 사용하여 createPost 함수를 실행시킵니다.
    createMutate.mutate({ title: title.value, content: content.value });
  };

  return (
    <div>
			<form onSubmit={handleSubmit}>
			{...중략}
			</form>
      {isLoading
        ? "LOADING..."
        : posts.map((post, index) => <div>{`${index}) ${post.title}`}</div>)}
    </div>
  );
}
```
app.jsx
​
useMutation를 사용해 생성, 업데이트, 삭제 등의 처리 할 수 있고, queryClient가 검색할 수 있는 Query key라면 queryClient.invalidateQueries(queryKey)를 통해 데이터를 손쉽게 갱신 해 줄 수 있습니다. 데이터를 갱신하는 방법은 이 밖에도 여러가지 방법이 있지만 여기서는 invalidateQueries 만 다루어 보았습니다.
이 밖에도 React-Query의 가능성은 무궁무진합니다. 해당 라이브러리에 대해 조금 더 알고 싶다면 공식 사이트를 방문해 주세요.